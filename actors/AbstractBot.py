#!/usr/bin/env python2
# coding=UTF-8
"""Defines abstract base classes for all kinds of bots"""
import logging
import os
import random
import shlex
import subprocess
import time
from abc import ABCMeta, abstractmethod
from blinker import signal
from threading import Timer, Thread, current_thread

from resources import emu_config


class Runnable(object):
    """A class that executes code, similar to the Java class of the same name"""
    __metaclass__ = ABCMeta

    def __init__(self, name=""):
        self.stopthread = False
        self.name = name
        self.processes = []  # A list of processes that can be stopped via terminate()

        signal('start').connect(self.start)
        signal('start ' + name).connect(self.start)
        signal('stop').connect(self.stop)
        signal('stop ' + name).connect(self.stop)

    @abstractmethod
    def start(self):
        """Starts the runnable so that it will perform its work. This may also be invoked by sending a start signal."""

    @abstractmethod
    def stop(self):
        """Stops the runnable so that it will not perform any further work until restartet.
        Its Thread may now safely be joined without the thread invoking join being blocked.
        This can alternatively be invoked by sending a stop signal."""


class AbstractBot(Runnable):
    """The abstract base class for all bots in the simulated botnets"""
    __metaclass__ = ABCMeta

    def __init__(self, peerlist=[], desinfect_timeout=10, probability_of_disinfection=0, name=""):
        Runnable.__init__(self, name=name)
        assert isinstance(peerlist, list), "type(peerlist): %s" % type(peerlist)

        self.peerlist = peerlist
        self.id = random.randint(1, 100000)
        self.disinfect_timeout = desinfect_timeout
        self.probability_of_disinfection = probability_of_disinfection

    def start(self, pauseBetweenDuties=emu_config.botcommand_timeout, args=()):
        """Starts the runnable, so that it performs its duties"""
        thread = Thread(name="Runnable %s" % self.name, target=self.doWork, args=(pauseBetweenDuties, args))
        thread.start()
        logging.debug("Started performing duties every %d seconds" % pauseBetweenDuties)

    def doWork(self, pauseBetweenDuties, args):
        """Does the actual work of this Runnable instance. Meant to be executed in a separate thread"""
        assert "Runnable" in current_thread().name
        while not self.stopthread:
            self.performDuty(args)
            time.sleep(pauseBetweenDuties)

    @abstractmethod
    def performDuty(self, args):
        """Does the actual work. Is called regularly and should be implemented by subclasses."""

    def stop(self, sender=None):
        """Shuts the bot down."""
        logging.info("Bot was stopped via signal from %s" % sender)
        self.stopthread = True
        for proc in self.processes:
            proc.terminate()

    def listenForIncomingNoiseTraffic(self):
        """Receives the trafic generated by sendOutRandomTraffic(). This should run on every Node, so we can choose targets at random."""
        recvprocess = subprocess.Popen(shlex.split("ITGRecv"))
        self.processes.append(recvprocess)
        recvprocess.wait()

def executeBot(bot, pauseBetweenDuties):
    """Helper method for executing the bot in a new thread.
    :param bot: The bot that shall be started.
    :param pauseBetweenDuties: How long to wait between invocations of performDuty()"""
    assert isinstance(bot, Runnable)
    bot.start(pauseBetweenDuties=pauseBetweenDuties)
